export class ImageLazyLoad {

  currentRequest: XMLHttpRequest | null = null

  /**
   * image file name (png, gif or jpg)
   */
  private readonly imgUrlOriginal: string

  /**
   * @param img image element in article content from markdown file
   * @param imgArticleRelativePath relative path of article of image. All image generated are in path relative of her parents Markdown file
   */
  constructor(private readonly img: HTMLImageElement, private readonly imgArticleRelativePath: string) {

    this.imgUrlOriginal = this.img.src
    this.img.src = ""

    this.setImageHas("icon")
      .then( () => { this.setListenerToLoadOriginalWhenImgIsVisible() })
      .catch(() => {
        this.img.src = ""
      })

  }

  public abort() {
    if( this.currentRequest ) this.currentRequest.abort()
    this.currentRequest = null
  }

  private async setImageHas(version: "icon" | "original") {
    const imgUrl = version === "icon" ? this.imgUrlIcon : this.imgUrlOriginal

    const imageBlob = await this.newImageLoadRequest( imgUrl )
    this.img.src = window.URL.createObjectURL( imageBlob )

  }

  private setListenerToLoadOriginalWhenImgIsVisible() {

    let isVisibleByUserIsRunning = false

    const loadOnVisible = () => { if(!isVisibleByUserIsRunning) {

        isVisibleByUserIsRunning = true

        setTimeout(() => {

          if( this.isVisibleByUser ) {

            this.setImageHas("original").catch( () => {
              this.img.src = ""
            })

            document.removeEventListener("scroll", loadOnVisible)
            window.removeEventListener("resize", loadOnVisible)
            window.removeEventListener("orientationchange", loadOnVisible)

          }

          isVisibleByUserIsRunning = false
        }, 200)

    }}

    document.addEventListener("scroll", loadOnVisible)
    window.addEventListener("resize", loadOnVisible)
    window.addEventListener("orientationchange", loadOnVisible)

  }

  private get isVisibleByUser(): boolean {

    const isInScreenView = this.img.getBoundingClientRect().top <= window.innerHeight && this.img.getBoundingClientRect().bottom >= 0

    return isInScreenView && getComputedStyle(this.img).display !== "none"
  }


  private async newImageLoadRequest(imgUrl: string): Promise<string> {
    return new Promise( (resolve, reject) => {

      this.currentRequest = new XMLHttpRequest()

      this.currentRequest.responseType = "blob"

      this.currentRequest.addEventListener("loadend", ev => {

        if( this.currentRequest && this.currentRequest.status === 200 ) resolve( this.currentRequest.response )
        else reject()

        this.currentRequest = null

      }, {once: true})

      this.currentRequest.addEventListener("error", () => {

        reject()
        this.currentRequest = null

      }, {once: true})

      this.currentRequest.addEventListener("abort", () => {

        reject()
        this.currentRequest = null

      }, {once: true})

      this.currentRequest.open("GET", imgUrl, true)

      this.currentRequest.send()

    })
  }

  /**
   * icon url of images in markdown files.
   * All images in markdown file are an icon version generated by imageResize in tools/ project directory
   */
  private get imgUrlIcon(): string {

    const imgFileName = this.imgUrlOriginal.split("/").pop()

    const smallImageName = "icon-" + imgFileName

    return `https://distortion.mastermediadesign.ch/resources${this.imgArticleRelativePath}${smallImageName}`
  }

}
